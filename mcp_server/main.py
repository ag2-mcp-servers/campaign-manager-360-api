# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T01:52:28+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, UnsuportedSecurityStub
from fastapi import Path, Query, Request
from pydantic import conint

from models import (
    Account,
    AccountActiveAdSummary,
    AccountPermission,
    AccountPermissionGroup,
    AccountPermissionGroupsListResponse,
    AccountPermissionsListResponse,
    AccountsListResponse,
    AccountUserProfile,
    AccountUserProfilesListResponse,
    Action,
    Ad,
    AdsListResponse,
    Advertiser,
    AdvertiserGroup,
    AdvertiserGroupIds,
    AdvertiserGroupsListResponse,
    AdvertiserIds,
    AdvertiserLandingPagesListResponse,
    AdvertisersListResponse,
    Alt,
    AudienceSegmentIds,
    BrowsersListResponse,
    Campaign,
    CampaignCreativeAssociation,
    CampaignCreativeAssociationsListResponse,
    CampaignIds,
    CampaignsListResponse,
    ChangeLog,
    ChangeLogsListResponse,
    CitiesListResponse,
    CompanionCreativeIds,
    Compatibilities,
    Compatibility,
    CompatibleFields,
    ConnectionType,
    ConnectionTypesListResponse,
    ContentCategoriesListResponse,
    ContentCategory,
    ContentCategoryIds,
    ConversionsBatchInsertRequest,
    ConversionsBatchInsertResponse,
    ConversionsBatchUpdateRequest,
    ConversionsBatchUpdateResponse,
    CountriesListResponse,
    Country,
    CountryDartIds,
    Creative,
    CreativeAssetMetadata,
    CreativeField,
    CreativeFieldIds,
    CreativeFieldsListResponse,
    CreativeFieldValue,
    CreativeFieldValuesListResponse,
    CreativeGroup,
    CreativeGroupsListResponse,
    CreativeIds,
    CreativeOptimizationConfigurationIds,
    CreativesListResponse,
    CustomEventsBatchInsertRequest,
    CustomEventsBatchInsertResponse,
    DartIds,
    DimensionValueList,
    DimensionValueRequest,
    Directories,
    DirectorySite,
    DirectorySiteIds,
    DirectorySitesListResponse,
    DynamicTargetingKey,
    DynamicTargetingKeysListResponse,
    EventTag,
    EventTagsListResponse,
    EventTagTypes,
    ExcludedIds,
    FieldXgafv,
    File,
    FileList,
    FloodlightActivitiesGenerateTagResponse,
    FloodlightActivitiesListResponse,
    FloodlightActivity,
    FloodlightActivityGroup,
    FloodlightActivityGroupIds,
    FloodlightActivityGroupsListResponse,
    FloodlightActivityGroupType,
    FloodlightConfiguration,
    FloodlightConfigurationIds,
    FloodlightConfigurationsListResponse,
    GroupIds,
    Ids,
    InventoryItem,
    InventoryItemsListResponse,
    LandingPage,
    LandingPageIds,
    LanguagesListResponse,
    MetrosListResponse,
    MobileApp,
    MobileAppsListResponse,
    MobileCarrier,
    MobileCarriersListResponse,
    Names,
    ObjectIds,
    ObjectType1,
    ObjectType3,
    OperatingSystem,
    OperatingSystemsListResponse,
    OperatingSystemVersion,
    OperatingSystemVersionsListResponse,
    Order,
    OrderDocument,
    OrderDocumentsListResponse,
    OrderId,
    OrdersListResponse,
    PaymentSource,
    Placement,
    PlacementGroup,
    PlacementGroupsListResponse,
    PlacementGroupType,
    PlacementIds,
    PlacementsGenerateTagsResponse,
    PlacementsListResponse,
    PlacementStrategiesListResponse,
    PlacementStrategy,
    PlacementStrategyIds,
    PlatformType,
    PlatformTypesListResponse,
    PostalCode,
    PostalCodesListResponse,
    PricingTypes,
    PricingTypes1,
    Project,
    ProjectsListResponse,
    RegionDartIds,
    RegionsListResponse,
    RemarketingList,
    RemarketingListIds,
    RemarketingListShare,
    RemarketingListsListResponse,
    RenderingIds,
    Report,
    ReportList,
    Scope,
    Scope2,
    Site,
    SiteId,
    SiteIds,
    SitesListResponse,
    Size,
    SizeIds,
    SizesListResponse,
    SortField,
    SortField18,
    SortField20,
    SortField28,
    SortField30,
    SortField50,
    SortField52,
    SortField54,
    SortOrder,
    Status6,
    Subaccount,
    SubaccountsListResponse,
    TagFormats,
    TargetableRemarketingList,
    TargetableRemarketingListsListResponse,
    TargetingTemplate,
    TargetingTemplatesListResponse,
    Type11,
    Type14,
    Type16,
    Types,
    UserProfile,
    UserProfileIds,
    UserProfileList,
    UserRole,
    UserRolePermission,
    UserRolePermissionGroup,
    UserRolePermissionGroupsListResponse,
    UserRolePermissionsListResponse,
    UserRolesListResponse,
    VideoFormat,
    VideoFormatsListResponse,
)

app = MCPProxy(
    contact={'name': 'Google', 'url': 'https://google.com', 'x-twitter': 'youtube'},
    description='Build applications to efficiently manage large or complex trafficking, reporting, and attribution workflows for Campaign Manager 360.',
    license={
        'name': 'Creative Commons Attribution 3.0',
        'url': 'http://creativecommons.org/licenses/by/3.0/',
    },
    termsOfService='https://developers.google.com/terms/',
    title='Campaign Manager 360 API',
    version='v3.4',
    servers=[{'url': 'https://dfareporting.googleapis.com/dfareporting/v3.4'}],
)


@app.get(
    '/reports/{reportId}/files/{fileId}',
    description=""" Retrieves a report file by its report ID and file ID. This method supports media download. """,
    tags=['dfareporting_report_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_files_get(
    report_id: str = Path(..., alias='reportId'),
    file_id: str = Path(..., alias='fileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles',
    description=""" Retrieves list of user profiles for a user. """,
    tags=[
        'dfareporting_user_profile_management',
        'dfareporting_account_operations',
        'dfareporting_report_handling',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_user_profiles_list(
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}',
    description=""" Gets one user profile by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_user_profiles_get(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/accountActiveAdSummaries/{summaryAccountId}',
    description=""" Gets the account's active ad summary by account ID. """,
    tags=['dfareporting_user_profile_management', 'dfareporting_account_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_account_active_ad_summaries_get(
    profile_id: str = Path(..., alias='profileId'),
    summary_account_id: str = Path(..., alias='summaryAccountId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/accountPermissionGroups',
    description=""" Retrieves the list of account permission groups. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_account_permission_groups_list(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/accountPermissionGroups/{id}',
    description=""" Gets one account permission group by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_account_permission_groups_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/accountPermissions',
    description=""" Retrieves the list of account permissions. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_account_permissions_list(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/accountPermissions/{id}',
    description=""" Gets one account permission by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_account_permissions_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/accountUserProfiles',
    description=""" Retrieves a list of account user profiles, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_account_user_profiles_list(
    profile_id: str = Path(..., alias='profileId'),
    active: Optional[bool] = None,
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    subaccount_id: Optional[str] = Query(None, alias='subaccountId'),
    user_role_id: Optional[str] = Query(None, alias='userRoleId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/accountUserProfiles',
    description=""" Updates an existing account user profile. This method supports patch semantics. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_account_user_profiles_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: AccountUserProfile = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/accountUserProfiles',
    description=""" Inserts a new account user profile. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_account_user_profiles_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: AccountUserProfile = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/accountUserProfiles',
    description=""" Updates an existing account user profile. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_account_user_profiles_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: AccountUserProfile = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/accountUserProfiles/{id}',
    description=""" Gets one account user profile by ID. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_account_user_profiles_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/accounts',
    description=""" Retrieves the list of accounts, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_accounts_list(
    profile_id: str = Path(..., alias='profileId'),
    active: Optional[bool] = None,
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/accounts',
    description=""" Updates an existing account. This method supports patch semantics. """,
    tags=['dfareporting_user_profile_management', 'dfareporting_account_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_accounts_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Account = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/accounts',
    description=""" Updates an existing account. """,
    tags=['dfareporting_user_profile_management', 'dfareporting_account_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_accounts_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Account = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/accounts/{id}',
    description=""" Gets one account by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_accounts_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/ads',
    description=""" Retrieves a list of ads, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management', 'remarketing_list_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_ads_list(
    profile_id: str = Path(..., alias='profileId'),
    active: Optional[bool] = None,
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    archived: Optional[bool] = None,
    audience_segment_ids: Optional[AudienceSegmentIds] = Query(
        None, alias='audienceSegmentIds'
    ),
    campaign_ids: Optional[CampaignIds] = Query(None, alias='campaignIds'),
    compatibility: Optional[Compatibility] = None,
    creative_ids: Optional[CreativeIds] = Query(None, alias='creativeIds'),
    creative_optimization_configuration_ids: Optional[
        CreativeOptimizationConfigurationIds
    ] = Query(None, alias='creativeOptimizationConfigurationIds'),
    dynamic_click_tracker: Optional[bool] = Query(None, alias='dynamicClickTracker'),
    ids: Optional[Ids] = None,
    landing_page_ids: Optional[LandingPageIds] = Query(None, alias='landingPageIds'),
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    overridden_event_tag_id: Optional[str] = Query(None, alias='overriddenEventTagId'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    placement_ids: Optional[PlacementIds] = Query(None, alias='placementIds'),
    remarketing_list_ids: Optional[RemarketingListIds] = Query(
        None, alias='remarketingListIds'
    ),
    search_string: Optional[str] = Query(None, alias='searchString'),
    size_ids: Optional[SizeIds] = Query(None, alias='sizeIds'),
    sort_field: Optional[SortField] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    ssl_compliant: Optional[bool] = Query(None, alias='sslCompliant'),
    ssl_required: Optional[bool] = Query(None, alias='sslRequired'),
    type: Optional[Type11] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/ads',
    description=""" Updates an existing ad. This method supports patch semantics. """,
    tags=['dfareporting_user_profile_management', 'dfareporting_ad_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_ads_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Ad = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/ads',
    description=""" Inserts a new ad. """,
    tags=['dfareporting_user_profile_management', 'dfareporting_ad_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_ads_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Ad = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/ads',
    description=""" Updates an existing ad. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_ads_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Ad = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/ads/{id}',
    description=""" Gets one ad by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_ads_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/advertiserGroups',
    description=""" Retrieves a list of advertiser groups, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_advertiser_groups_list(
    profile_id: str = Path(..., alias='profileId'),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/advertiserGroups',
    description=""" Updates an existing advertiser group. This method supports patch semantics. """,
    tags=['dfareporting_advertiser_group_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_advertiser_groups_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: AdvertiserGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/advertiserGroups',
    description=""" Inserts a new advertiser group. """,
    tags=['dfareporting_advertiser_group_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_advertiser_groups_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: AdvertiserGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/advertiserGroups',
    description=""" Updates an existing advertiser group. """,
    tags=['dfareporting_advertiser_group_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_advertiser_groups_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: AdvertiserGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/userprofiles/{profileId}/advertiserGroups/{id}',
    description=""" Deletes an existing advertiser group. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_advertiser_groups_delete(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/advertiserGroups/{id}',
    description=""" Gets one advertiser group by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_advertiser_groups_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/advertiserLandingPages',
    description=""" Retrieves a list of landing pages. """,
    tags=[
        'dfareporting_user_profile_management',
        'subaccount_operations',
        'advertiser_operations',
        'campaign_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_advertiser_landing_pages_list(
    profile_id: str = Path(..., alias='profileId'),
    advertiser_ids: Optional[AdvertiserIds] = Query(None, alias='advertiserIds'),
    archived: Optional[bool] = None,
    campaign_ids: Optional[CampaignIds] = Query(None, alias='campaignIds'),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    subaccount_id: Optional[str] = Query(None, alias='subaccountId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/advertiserLandingPages',
    description=""" Updates an existing advertiser landing page. This method supports patch semantics. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_advertiser_landing_pages_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: LandingPage = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/advertiserLandingPages',
    description=""" Inserts a new landing page. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_advertiser_landing_pages_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: LandingPage = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/advertiserLandingPages',
    description=""" Updates an existing landing page. """,
    tags=[
        'dfareporting_user_profile_management',
        'dfareporting_landing_page_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_advertiser_landing_pages_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: LandingPage = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/advertiserLandingPages/{id}',
    description=""" Gets one landing page by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_advertiser_landing_pages_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/advertisers',
    description=""" Retrieves a list of advertisers, possibly filtered. This method supports paging. """,
    tags=[
        'dfareporting_user_profile_management',
        'dfareporting_advertiser_group_operations',
        'advertiser_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_advertisers_list(
    profile_id: str = Path(..., alias='profileId'),
    advertiser_group_ids: Optional[AdvertiserGroupIds] = Query(
        None, alias='advertiserGroupIds'
    ),
    floodlight_configuration_ids: Optional[FloodlightConfigurationIds] = Query(
        None, alias='floodlightConfigurationIds'
    ),
    ids: Optional[Ids] = None,
    include_advertisers_without_groups_only: Optional[bool] = Query(
        None, alias='includeAdvertisersWithoutGroupsOnly'
    ),
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    only_parent: Optional[bool] = Query(None, alias='onlyParent'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    status: Optional[Status6] = None,
    subaccount_id: Optional[str] = Query(None, alias='subaccountId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/advertisers',
    description=""" Updates an existing advertiser. This method supports patch semantics. """,
    tags=['dfareporting_user_profile_management', 'advertiser_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_advertisers_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Advertiser = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/advertisers',
    description=""" Inserts a new advertiser. """,
    tags=['dfareporting_user_profile_management', 'advertiser_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_advertisers_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Advertiser = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/advertisers',
    description=""" Updates an existing advertiser. """,
    tags=['dfareporting_user_profile_management', 'advertiser_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_advertisers_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Advertiser = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/advertisers/{id}',
    description=""" Gets one advertiser by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_advertisers_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/browsers',
    description=""" Retrieves a list of browsers. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_browsers_list(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/campaigns',
    description=""" Retrieves a list of campaigns, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management', 'subaccount_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_campaigns_list(
    profile_id: str = Path(..., alias='profileId'),
    advertiser_group_ids: Optional[AdvertiserGroupIds] = Query(
        None, alias='advertiserGroupIds'
    ),
    advertiser_ids: Optional[AdvertiserIds] = Query(None, alias='advertiserIds'),
    archived: Optional[bool] = None,
    at_least_one_optimization_activity: Optional[bool] = Query(
        None, alias='atLeastOneOptimizationActivity'
    ),
    excluded_ids: Optional[ExcludedIds] = Query(None, alias='excludedIds'),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    overridden_event_tag_id: Optional[str] = Query(None, alias='overriddenEventTagId'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    subaccount_id: Optional[str] = Query(None, alias='subaccountId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/campaigns',
    description=""" Updates an existing campaign. This method supports patch semantics. """,
    tags=['dfareporting_campaign_operations', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_campaigns_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Campaign = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/campaigns',
    description=""" Inserts a new campaign. """,
    tags=['dfareporting_user_profile_management', 'campaign_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_campaigns_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Campaign = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/campaigns',
    description=""" Updates an existing campaign. """,
    tags=['dfareporting_user_profile_management', 'campaign_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_campaigns_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Campaign = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/campaigns/{campaignId}/campaignCreativeAssociations',
    description=""" Retrieves the list of creative IDs associated with the specified campaign. This method supports paging. """,
    tags=['dfareporting_user_profile_management', 'campaign_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_campaign_creative_associations_list(
    profile_id: str = Path(..., alias='profileId'),
    campaign_id: str = Path(..., alias='campaignId'),
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/campaigns/{campaignId}/campaignCreativeAssociations',
    description=""" Associates a creative with the specified campaign. This method creates a default ad with dimensions matching the creative in the campaign if such a default ad does not exist already. """,
    tags=['campaign_operations', 'creative_association_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_campaign_creative_associations_insert(
    profile_id: str = Path(..., alias='profileId'),
    campaign_id: str = Path(..., alias='campaignId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: CampaignCreativeAssociation = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/campaigns/{id}',
    description=""" Gets one campaign by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_campaigns_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/changeLogs',
    description=""" Retrieves a list of change logs. This method supports paging. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_change_logs_list(
    profile_id: str = Path(..., alias='profileId'),
    action: Optional[Action] = None,
    ids: Optional[Ids] = None,
    max_change_time: Optional[str] = Query(None, alias='maxChangeTime'),
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    min_change_time: Optional[str] = Query(None, alias='minChangeTime'),
    object_ids: Optional[ObjectIds] = Query(None, alias='objectIds'),
    object_type: Optional[ObjectType1] = Query(None, alias='objectType'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    user_profile_ids: Optional[UserProfileIds] = Query(None, alias='userProfileIds'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/changeLogs/{id}',
    description=""" Gets one change log by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_change_logs_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/cities',
    description=""" Retrieves a list of cities, possibly filtered. """,
    tags=[
        'dfareporting_user_profile_management',
        'dfareporting_country_data_management',
        'dfareporting_region_data_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_cities_list(
    profile_id: str = Path(..., alias='profileId'),
    country_dart_ids: Optional[CountryDartIds] = Query(None, alias='countryDartIds'),
    dart_ids: Optional[DartIds] = Query(None, alias='dartIds'),
    name_prefix: Optional[str] = Query(None, alias='namePrefix'),
    region_dart_ids: Optional[RegionDartIds] = Query(None, alias='regionDartIds'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/connectionTypes',
    description=""" Retrieves a list of connection types. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_connection_types_list(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/connectionTypes/{id}',
    description=""" Gets one connection type by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_connection_types_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/contentCategories',
    description=""" Retrieves a list of content categories, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_content_categories_list(
    profile_id: str = Path(..., alias='profileId'),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/contentCategories',
    description=""" Updates an existing content category. This method supports patch semantics. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_content_categories_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: ContentCategory = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/contentCategories',
    description=""" Inserts a new content category. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_content_categories_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: ContentCategory = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/contentCategories',
    description=""" Updates an existing content category. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_content_categories_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: ContentCategory = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/userprofiles/{profileId}/contentCategories/{id}',
    description=""" Deletes an existing content category. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_content_categories_delete(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/contentCategories/{id}',
    description=""" Gets one content category by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_content_categories_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/conversions/batchinsert',
    description=""" Inserts conversions. """,
    tags=['dfareporting_custom_event_management', 'conversion_tracking_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_conversions_batchinsert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: ConversionsBatchInsertRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/conversions/batchupdate',
    description=""" Updates existing conversions. """,
    tags=['dfareporting_user_profile_management', 'conversion_tracking_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_conversions_batchupdate(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: ConversionsBatchUpdateRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/countries',
    description=""" Retrieves a list of countries. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_countries_list(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/countries/{dartId}',
    description=""" Gets one country by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_countries_get(
    profile_id: str = Path(..., alias='profileId'),
    dart_id: str = Path(..., alias='dartId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/creativeAssets/{advertiserId}/creativeAssets',
    description=""" Inserts a new creative asset. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_assets_insert(
    profile_id: str = Path(..., alias='profileId'),
    advertiser_id: str = Path(..., alias='advertiserId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    request: Request = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/creativeFields',
    description=""" Retrieves a list of creative fields, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_fields_list(
    profile_id: str = Path(..., alias='profileId'),
    advertiser_ids: Optional[AdvertiserIds] = Query(None, alias='advertiserIds'),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/creativeFields',
    description=""" Updates an existing creative field. This method supports patch semantics. """,
    tags=[
        'dfareporting_user_profile_management',
        'dfareporting_creative_field_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_fields_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: CreativeField = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/creativeFields',
    description=""" Inserts a new creative field. """,
    tags=[
        'dfareporting_user_profile_management',
        'dfareporting_creative_field_operations',
        'dfareporting_creative_field_value_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_fields_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: CreativeField = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/creativeFields',
    description=""" Updates an existing creative field. """,
    tags=[
        'dfareporting_user_profile_management',
        'dfareporting_creative_field_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_fields_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: CreativeField = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues',
    description=""" Retrieves a list of creative field values, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_field_values_list(
    profile_id: str = Path(..., alias='profileId'),
    creative_field_id: str = Path(..., alias='creativeFieldId'),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField18] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues',
    description=""" Updates an existing creative field value. This method supports patch semantics. """,
    tags=[
        'dfareporting_creative_field_value_operations',
        'dfareporting_creative_field_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_field_values_patch(
    profile_id: str = Path(..., alias='profileId'),
    creative_field_id: str = Path(..., alias='creativeFieldId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: CreativeFieldValue = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues',
    description=""" Inserts a new creative field value. """,
    tags=['dfareporting_creative_field_value_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_field_values_insert(
    profile_id: str = Path(..., alias='profileId'),
    creative_field_id: str = Path(..., alias='creativeFieldId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: CreativeFieldValue = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues',
    description=""" Updates an existing creative field value. """,
    tags=['dfareporting_creative_field_value_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_field_values_update(
    profile_id: str = Path(..., alias='profileId'),
    creative_field_id: str = Path(..., alias='creativeFieldId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: CreativeFieldValue = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues/{id}',
    description=""" Deletes an existing creative field value. """,
    tags=[
        'dfareporting_creative_field_operations',
        'dfareporting_creative_field_value_operations',
        'dfareporting_creative_handling',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_field_values_delete(
    profile_id: str = Path(..., alias='profileId'),
    creative_field_id: str = Path(..., alias='creativeFieldId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/creativeFields/{creativeFieldId}/creativeFieldValues/{id}',
    description=""" Gets one creative field value by ID. """,
    tags=[
        'dfareporting_creative_field_operations',
        'dfareporting_creative_field_value_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_field_values_get(
    profile_id: str = Path(..., alias='profileId'),
    creative_field_id: str = Path(..., alias='creativeFieldId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/userprofiles/{profileId}/creativeFields/{id}',
    description=""" Deletes an existing creative field. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_fields_delete(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/creativeFields/{id}',
    description=""" Gets one creative field by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_fields_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/creativeGroups',
    description=""" Retrieves a list of creative groups, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_groups_list(
    profile_id: str = Path(..., alias='profileId'),
    advertiser_ids: Optional[AdvertiserIds] = Query(None, alias='advertiserIds'),
    group_number: Optional[conint(ge=1, le=2)] = Query(None, alias='groupNumber'),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField20] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/creativeGroups',
    description=""" Updates an existing creative group. This method supports patch semantics. """,
    tags=['dfareporting_creative_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_groups_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: CreativeGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/creativeGroups',
    description=""" Inserts a new creative group. """,
    tags=['dfareporting_creative_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_groups_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: CreativeGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/creativeGroups',
    description=""" Updates an existing creative group. """,
    tags=['dfareporting_creative_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_groups_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: CreativeGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/creativeGroups/{id}',
    description=""" Gets one creative group by ID. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creative_groups_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/creatives',
    description=""" Retrieves a list of creatives, possibly filtered. This method supports paging. """,
    tags=[
        'dfareporting_user_profile_management',
        'advertiser_operations',
        'campaign_operations',
        'creative_association_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creatives_list(
    profile_id: str = Path(..., alias='profileId'),
    active: Optional[bool] = None,
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    archived: Optional[bool] = None,
    campaign_id: Optional[str] = Query(None, alias='campaignId'),
    companion_creative_ids: Optional[CompanionCreativeIds] = Query(
        None, alias='companionCreativeIds'
    ),
    creative_field_ids: Optional[CreativeFieldIds] = Query(
        None, alias='creativeFieldIds'
    ),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    rendering_ids: Optional[RenderingIds] = Query(None, alias='renderingIds'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    size_ids: Optional[SizeIds] = Query(None, alias='sizeIds'),
    sort_field: Optional[SortField20] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    studio_creative_id: Optional[str] = Query(None, alias='studioCreativeId'),
    types: Optional[Types] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/creatives',
    description=""" Updates an existing creative. This method supports patch semantics. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creatives_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Creative = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/creatives',
    description=""" Inserts a new creative. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creatives_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Creative = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/creatives',
    description=""" Updates an existing creative. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creatives_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Creative = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/creatives/{id}',
    description=""" Gets one creative by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_creatives_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/customEvents/batchinsert',
    description=""" Inserts custom events. """,
    tags=['dfareporting_custom_event_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_custom_events_batchinsert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: CustomEventsBatchInsertRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/dimensionvalues/query',
    description=""" Retrieves list of report dimension values for a list of filters. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_dimension_values_query(
    profile_id: str = Path(..., alias='profileId'),
    max_results: Optional[conint(ge=0, le=100)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: DimensionValueRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/directorySites',
    description=""" Retrieves a list of directory sites, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_directory_sites_list(
    profile_id: str = Path(..., alias='profileId'),
    accepts_in_stream_video_placements: Optional[bool] = Query(
        None, alias='acceptsInStreamVideoPlacements'
    ),
    accepts_interstitial_placements: Optional[bool] = Query(
        None, alias='acceptsInterstitialPlacements'
    ),
    accepts_publisher_paid_placements: Optional[bool] = Query(
        None, alias='acceptsPublisherPaidPlacements'
    ),
    active: Optional[bool] = None,
    dfp_network_code: Optional[str] = Query(None, alias='dfpNetworkCode'),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField20] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/directorySites',
    description=""" Inserts a new directory site. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_directory_sites_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: DirectorySite = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/directorySites/{id}',
    description=""" Gets one directory site by ID. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_directory_sites_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/dynamicTargetingKeys',
    description=""" Retrieves a list of dynamic targeting keys. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_dynamic_targeting_keys_list(
    profile_id: str = Path(..., alias='profileId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    names: Optional[Names] = None,
    object_id: Optional[str] = Query(None, alias='objectId'),
    object_type: Optional[ObjectType3] = Query(None, alias='objectType'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/dynamicTargetingKeys',
    description=""" Inserts a new dynamic targeting key. Keys must be created at the advertiser level before being assigned to the advertiser's ads, creatives, or placements. There is a maximum of 1000 keys per advertiser, out of which a maximum of 20 keys can be assigned per ad, creative, or placement. """,
    tags=[
        'dfareporting_user_profile_management',
        'profile_data_management',
        'dfareporting_dynamic_targeting_key_management',
        'dynamic_targeting_key_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_dynamic_targeting_keys_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: DynamicTargetingKey = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/userprofiles/{profileId}/dynamicTargetingKeys/{objectId}',
    description=""" Deletes an existing dynamic targeting key. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_dynamic_targeting_keys_delete(
    profile_id: str = Path(..., alias='profileId'),
    object_id: str = Path(..., alias='objectId'),
    name: str = ...,
    object_type: ObjectType3 = Query(..., alias='objectType'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/eventTags',
    description=""" Retrieves a list of event tags, possibly filtered. """,
    tags=[
        'dfareporting_user_profile_management',
        'dfareporting_ad_operations',
        'campaign_operations',
        'advertiser_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_event_tags_list(
    profile_id: str = Path(..., alias='profileId'),
    ad_id: Optional[str] = Query(None, alias='adId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    campaign_id: Optional[str] = Query(None, alias='campaignId'),
    definitions_only: Optional[bool] = Query(None, alias='definitionsOnly'),
    enabled: Optional[bool] = None,
    event_tag_types: Optional[EventTagTypes] = Query(None, alias='eventTagTypes'),
    ids: Optional[Ids] = None,
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField20] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/eventTags',
    description=""" Updates an existing event tag. This method supports patch semantics. """,
    tags=['dfareporting_event_tag_operations', 'dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_event_tags_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: EventTag = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/eventTags',
    description=""" Inserts a new event tag. """,
    tags=['dfareporting_user_profile_management', 'event_tag_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_event_tags_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: EventTag = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/eventTags',
    description=""" Updates an existing event tag. """,
    tags=['dfareporting_user_profile_management', 'event_tag_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_event_tags_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: EventTag = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/userprofiles/{profileId}/eventTags/{id}',
    description=""" Deletes an existing event tag. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_event_tags_delete(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/eventTags/{id}',
    description=""" Gets one event tag by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_event_tags_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/files',
    description=""" Lists files for a user profile. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_files_list(
    profile_id: str = Path(..., alias='profileId'),
    max_results: Optional[conint(ge=0, le=10)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    scope: Optional[Scope] = None,
    sort_field: Optional[SortField28] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/floodlightActivities',
    description=""" Retrieves a list of floodlight activities, possibly filtered. This method supports paging. """,
    tags=[
        'floodlight_activity_group_management',
        'floodlight_activity_management',
        'dfareporting_user_profile_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_floodlight_activities_list(
    profile_id: str = Path(..., alias='profileId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    floodlight_activity_group_ids: Optional[FloodlightActivityGroupIds] = Query(
        None, alias='floodlightActivityGroupIds'
    ),
    floodlight_activity_group_name: Optional[str] = Query(
        None, alias='floodlightActivityGroupName'
    ),
    floodlight_activity_group_tag_string: Optional[str] = Query(
        None, alias='floodlightActivityGroupTagString'
    ),
    floodlight_activity_group_type: Optional[FloodlightActivityGroupType] = Query(
        None, alias='floodlightActivityGroupType'
    ),
    floodlight_configuration_id: Optional[str] = Query(
        None, alias='floodlightConfigurationId'
    ),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField30] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    tag_string: Optional[str] = Query(None, alias='tagString'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/floodlightActivities',
    description=""" Updates an existing floodlight activity. This method supports patch semantics. """,
    tags=['floodlight_activity_management', 'dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_floodlight_activities_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: FloodlightActivity = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/floodlightActivities',
    description=""" Inserts a new floodlight activity. """,
    tags=['floodlight_activity_management', 'dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_floodlight_activities_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: FloodlightActivity = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/floodlightActivities',
    description=""" Updates an existing floodlight activity. """,
    tags=['dfareporting_user_profile_management', 'floodlight_activity_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_floodlight_activities_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: FloodlightActivity = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/floodlightActivities/generatetag',
    description=""" Generates a tag for a floodlight activity. """,
    tags=['dfareporting_user_profile_management', 'floodlight_activity_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_floodlight_activities_generatetag(
    profile_id: str = Path(..., alias='profileId'),
    floodlight_activity_id: Optional[str] = Query(None, alias='floodlightActivityId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/userprofiles/{profileId}/floodlightActivities/{id}',
    description=""" Deletes an existing floodlight activity. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_floodlight_activities_delete(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/floodlightActivities/{id}',
    description=""" Gets one floodlight activity by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_floodlight_activities_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/floodlightActivityGroups',
    description=""" Retrieves a list of floodlight activity groups, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_floodlight_activity_groups_list(
    profile_id: str = Path(..., alias='profileId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    floodlight_configuration_id: Optional[str] = Query(
        None, alias='floodlightConfigurationId'
    ),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField30] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    type: Optional[Type14] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/floodlightActivityGroups',
    description=""" Updates an existing floodlight activity group. This method supports patch semantics. """,
    tags=['floodlight_activity_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_floodlight_activity_groups_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: FloodlightActivityGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/floodlightActivityGroups',
    description=""" Inserts a new floodlight activity group. """,
    tags=['floodlight_activity_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_floodlight_activity_groups_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: FloodlightActivityGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/floodlightActivityGroups',
    description=""" Updates an existing floodlight activity group. """,
    tags=['floodlight_activity_group_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_floodlight_activity_groups_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: FloodlightActivityGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/floodlightActivityGroups/{id}',
    description=""" Gets one floodlight activity group by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_floodlight_activity_groups_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/floodlightConfigurations',
    description=""" Retrieves a list of floodlight configurations, possibly filtered. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_floodlight_configurations_list(
    profile_id: str = Path(..., alias='profileId'),
    ids: Optional[Ids] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/floodlightConfigurations',
    description=""" Updates an existing floodlight configuration. This method supports patch semantics. """,
    tags=[
        'dfareporting_user_profile_management',
        'floodlight_configuration_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_floodlight_configurations_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: FloodlightConfiguration = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/floodlightConfigurations',
    description=""" Updates an existing floodlight configuration. """,
    tags=[
        'dfareporting_user_profile_management',
        'floodlight_configuration_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_floodlight_configurations_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: FloodlightConfiguration = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/floodlightConfigurations/{id}',
    description=""" Gets one floodlight configuration by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_floodlight_configurations_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/languages',
    description=""" Retrieves a list of languages. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_languages_list(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/metros',
    description=""" Retrieves a list of metros. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_metros_list(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/mobileApps',
    description=""" Retrieves list of available mobile apps. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_mobile_apps_list(
    profile_id: str = Path(..., alias='profileId'),
    directories: Optional[Directories] = None,
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/mobileApps/{id}',
    description=""" Gets one mobile app by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_mobile_apps_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/mobileCarriers',
    description=""" Retrieves a list of mobile carriers. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_mobile_carriers_list(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/mobileCarriers/{id}',
    description=""" Gets one mobile carrier by ID. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_mobile_carriers_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/operatingSystemVersions',
    description=""" Retrieves a list of operating system versions. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_operating_system_versions_list(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/operatingSystemVersions/{id}',
    description=""" Gets one operating system version by ID. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_operating_system_versions_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/operatingSystems',
    description=""" Retrieves a list of operating systems. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_operating_systems_list(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/operatingSystems/{dartId}',
    description=""" Gets one operating system by DART ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_operating_systems_get(
    profile_id: str = Path(..., alias='profileId'),
    dart_id: str = Path(..., alias='dartId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/placementGroups',
    description=""" Retrieves a list of placement groups, possibly filtered. This method supports paging. """,
    tags=[
        'dfareporting_user_profile_management',
        'advertiser_operations',
        'campaign_operations',
        'dfareporting_directory_site_management',
        'dfareporting_advertiser_group_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placement_groups_list(
    profile_id: str = Path(..., alias='profileId'),
    advertiser_ids: Optional[AdvertiserIds] = Query(None, alias='advertiserIds'),
    archived: Optional[bool] = None,
    campaign_ids: Optional[CampaignIds] = Query(None, alias='campaignIds'),
    content_category_ids: Optional[ContentCategoryIds] = Query(
        None, alias='contentCategoryIds'
    ),
    directory_site_ids: Optional[DirectorySiteIds] = Query(
        None, alias='directorySiteIds'
    ),
    ids: Optional[Ids] = None,
    max_end_date: Optional[str] = Query(None, alias='maxEndDate'),
    max_results: Optional[conint(ge=0, le=800)] = Query(None, alias='maxResults'),
    max_start_date: Optional[str] = Query(None, alias='maxStartDate'),
    min_end_date: Optional[str] = Query(None, alias='minEndDate'),
    min_start_date: Optional[str] = Query(None, alias='minStartDate'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    placement_group_type: Optional[PlacementGroupType] = Query(
        None, alias='placementGroupType'
    ),
    placement_strategy_ids: Optional[PlacementStrategyIds] = Query(
        None, alias='placementStrategyIds'
    ),
    pricing_types: Optional[PricingTypes] = Query(None, alias='pricingTypes'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    site_ids: Optional[SiteIds] = Query(None, alias='siteIds'),
    sort_field: Optional[SortField30] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/placementGroups',
    description=""" Updates an existing placement group. This method supports patch semantics. """,
    tags=['dfareporting_placement_group_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placement_groups_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: PlacementGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/placementGroups',
    description=""" Inserts a new placement group. """,
    tags=['dfareporting_placement_group_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placement_groups_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: PlacementGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/placementGroups',
    description=""" Updates an existing placement group. """,
    tags=['dfareporting_placement_group_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placement_groups_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: PlacementGroup = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/placementGroups/{id}',
    description=""" Gets one placement group by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placement_groups_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/placementStrategies',
    description=""" Retrieves a list of placement strategies, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placement_strategies_list(
    profile_id: str = Path(..., alias='profileId'),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField30] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/placementStrategies',
    description=""" Updates an existing placement strategy. This method supports patch semantics. """,
    tags=[
        'dfareporting_user_profile_management',
        'dfareporting_placement_strategy_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placement_strategies_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: PlacementStrategy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/placementStrategies',
    description=""" Inserts a new placement strategy. """,
    tags=['dfareporting_placement_strategy_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placement_strategies_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: PlacementStrategy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/placementStrategies',
    description=""" Updates an existing placement strategy. """,
    tags=[
        'dfareporting_user_profile_management',
        'dfareporting_placement_strategy_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placement_strategies_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: PlacementStrategy = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/userprofiles/{profileId}/placementStrategies/{id}',
    description=""" Deletes an existing placement strategy. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placement_strategies_delete(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/placementStrategies/{id}',
    description=""" Gets one placement strategy by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placement_strategies_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/placements',
    description=""" Retrieves a list of placements, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placements_list(
    profile_id: str = Path(..., alias='profileId'),
    advertiser_ids: Optional[AdvertiserIds] = Query(None, alias='advertiserIds'),
    archived: Optional[bool] = None,
    campaign_ids: Optional[CampaignIds] = Query(None, alias='campaignIds'),
    compatibilities: Optional[Compatibilities] = None,
    content_category_ids: Optional[ContentCategoryIds] = Query(
        None, alias='contentCategoryIds'
    ),
    directory_site_ids: Optional[DirectorySiteIds] = Query(
        None, alias='directorySiteIds'
    ),
    group_ids: Optional[GroupIds] = Query(None, alias='groupIds'),
    ids: Optional[Ids] = None,
    max_end_date: Optional[str] = Query(None, alias='maxEndDate'),
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    max_start_date: Optional[str] = Query(None, alias='maxStartDate'),
    min_end_date: Optional[str] = Query(None, alias='minEndDate'),
    min_start_date: Optional[str] = Query(None, alias='minStartDate'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    payment_source: Optional[PaymentSource] = Query(None, alias='paymentSource'),
    placement_strategy_ids: Optional[PlacementStrategyIds] = Query(
        None, alias='placementStrategyIds'
    ),
    pricing_types: Optional[PricingTypes1] = Query(None, alias='pricingTypes'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    site_ids: Optional[SiteIds] = Query(None, alias='siteIds'),
    size_ids: Optional[SizeIds] = Query(None, alias='sizeIds'),
    sort_field: Optional[SortField30] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/placements',
    description=""" Updates an existing placement. This method supports patch semantics. """,
    tags=['dfareporting_user_profile_management', 'dfareporting_placement_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placements_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Placement = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/placements',
    description=""" Inserts a new placement. """,
    tags=['dfareporting_user_profile_management', 'dfareporting_placement_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placements_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Placement = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/placements',
    description=""" Updates an existing placement. """,
    tags=['dfareporting_user_profile_management', 'dfareporting_placement_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placements_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Placement = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/placements/generatetags',
    description=""" Generates tags for a placement. """,
    tags=[
        'dfareporting_user_profile_management',
        'campaign_operations',
        'dfareporting_placement_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placements_generatetags(
    profile_id: str = Path(..., alias='profileId'),
    campaign_id: Optional[str] = Query(None, alias='campaignId'),
    placement_ids: Optional[PlacementIds] = Query(None, alias='placementIds'),
    tag_formats: Optional[TagFormats] = Query(None, alias='tagFormats'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/placements/{id}',
    description=""" Gets one placement by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_placements_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/platformTypes',
    description=""" Retrieves a list of platform types. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_platform_types_list(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/platformTypes/{id}',
    description=""" Gets one platform type by ID. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_platform_types_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/postalCodes',
    description=""" Retrieves a list of postal codes. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_postal_codes_list(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/postalCodes/{code}',
    description=""" Gets one postal code by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_postal_codes_get(
    profile_id: str = Path(..., alias='profileId'),
    code: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/projects',
    description=""" Retrieves a list of projects, possibly filtered. This method supports paging . """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_projects_list(
    profile_id: str = Path(..., alias='profileId'),
    advertiser_ids: Optional[AdvertiserIds] = Query(None, alias='advertiserIds'),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField30] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/projects/{id}',
    description=""" Gets one project by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_projects_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/projects/{projectId}/inventoryItems',
    description=""" Retrieves a list of inventory items, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management', 'dfareporting_project_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_inventory_items_list(
    profile_id: str = Path(..., alias='profileId'),
    project_id: str = Path(..., alias='projectId'),
    ids: Optional[Ids] = None,
    in_plan: Optional[bool] = Query(None, alias='inPlan'),
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    order_id: Optional[OrderId] = Query(None, alias='orderId'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    site_id: Optional[SiteId] = Query(None, alias='siteId'),
    sort_field: Optional[SortField30] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    type: Optional[Type16] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/projects/{projectId}/inventoryItems/{id}',
    description=""" Gets one inventory item by ID. """,
    tags=['dfareporting_user_profile_management', 'dfareporting_project_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_inventory_items_get(
    profile_id: str = Path(..., alias='profileId'),
    project_id: str = Path(..., alias='projectId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/projects/{projectId}/orderDocuments',
    description=""" Retrieves a list of order documents, possibly filtered. This method supports paging. """,
    tags=['dfareporting_project_operations', 'dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_order_documents_list(
    profile_id: str = Path(..., alias='profileId'),
    project_id: str = Path(..., alias='projectId'),
    approved: Optional[bool] = None,
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    order_id: Optional[OrderId] = Query(None, alias='orderId'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    site_id: Optional[SiteId] = Query(None, alias='siteId'),
    sort_field: Optional[SortField30] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/projects/{projectId}/orderDocuments/{id}',
    description=""" Gets one order document by ID. """,
    tags=['dfareporting_user_profile_management', 'dfareporting_project_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_order_documents_get(
    profile_id: str = Path(..., alias='profileId'),
    project_id: str = Path(..., alias='projectId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/projects/{projectId}/orders',
    description=""" Retrieves a list of orders, possibly filtered. This method supports paging. """,
    tags=[
        'dfareporting_user_profile_management',
        'dfareporting_project_operations',
        'profile_data_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_orders_list(
    profile_id: str = Path(..., alias='profileId'),
    project_id: str = Path(..., alias='projectId'),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    site_id: Optional[SiteId] = Query(None, alias='siteId'),
    sort_field: Optional[SortField30] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/projects/{projectId}/orders/{id}',
    description=""" Gets one order by ID. """,
    tags=['dfareporting_user_profile_management', 'dfareporting_project_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_orders_get(
    profile_id: str = Path(..., alias='profileId'),
    project_id: str = Path(..., alias='projectId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/regions',
    description=""" Retrieves a list of regions. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_regions_list(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/remarketingListShares',
    description=""" Updates an existing remarketing list share. This method supports patch semantics. """,
    tags=[
        'dfareporting_remarketing_list_operations',
        'dfareporting_user_profile_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_remarketing_list_shares_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: RemarketingListShare = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/remarketingListShares',
    description=""" Updates an existing remarketing list share. """,
    tags=[
        'dfareporting_remarketing_list_operations',
        'dfareporting_user_profile_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_remarketing_list_shares_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: RemarketingListShare = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/remarketingListShares/{remarketingListId}',
    description=""" Gets one remarketing list share by remarketing list ID. """,
    tags=['dfareporting_remarketing_list_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_remarketing_list_shares_get(
    profile_id: str = Path(..., alias='profileId'),
    remarketing_list_id: str = Path(..., alias='remarketingListId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/remarketingLists',
    description=""" Retrieves a list of remarketing lists, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_remarketing_lists_list(
    profile_id: str = Path(..., alias='profileId'),
    advertiser_id: str = Query(..., alias='advertiserId'),
    active: Optional[bool] = None,
    floodlight_activity_id: Optional[str] = Query(None, alias='floodlightActivityId'),
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    name: Optional[str] = None,
    page_token: Optional[str] = Query(None, alias='pageToken'),
    sort_field: Optional[SortField30] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/remarketingLists',
    description=""" Updates an existing remarketing list. This method supports patch semantics. """,
    tags=[
        'dfareporting_remarketing_list_operations',
        'dfareporting_user_profile_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_remarketing_lists_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: RemarketingList = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/remarketingLists',
    description=""" Inserts a new remarketing list. """,
    tags=['dfareporting_remarketing_list_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_remarketing_lists_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: RemarketingList = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/remarketingLists',
    description=""" Updates an existing remarketing list. """,
    tags=['dfareporting_remarketing_list_operations', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_remarketing_lists_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: RemarketingList = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/remarketingLists/{id}',
    description=""" Gets one remarketing list by ID. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_remarketing_lists_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/reports',
    description=""" Retrieves list of reports. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_reports_list(
    profile_id: str = Path(..., alias='profileId'),
    max_results: Optional[conint(ge=0, le=10)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    scope: Optional[Scope2] = None,
    sort_field: Optional[SortField50] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/reports',
    description=""" Creates a report. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_reports_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Report = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/reports/compatiblefields/query',
    description=""" Returns the fields that are compatible to be selected in the respective sections of a report criteria, given the fields already selected in the input report and user permissions. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_reports_compatible_fields_query(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Report = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/userprofiles/{profileId}/reports/{reportId}',
    description=""" Deletes a report by its ID. """,
    tags=['dfareporting_user_profile_management', 'dfareporting_report_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_reports_delete(
    profile_id: str = Path(..., alias='profileId'),
    report_id: str = Path(..., alias='reportId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/reports/{reportId}',
    description=""" Retrieves a report by its ID. """,
    tags=['dfareporting_report_handling', 'dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_reports_get(
    profile_id: str = Path(..., alias='profileId'),
    report_id: str = Path(..., alias='reportId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/reports/{reportId}',
    description=""" Updates an existing report. This method supports patch semantics. """,
    tags=['dfareporting_report_handling', 'dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_reports_patch(
    profile_id: str = Path(..., alias='profileId'),
    report_id: str = Path(..., alias='reportId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Report = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/reports/{reportId}',
    description=""" Updates a report. """,
    tags=['dfareporting_report_handling', 'dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_reports_update(
    profile_id: str = Path(..., alias='profileId'),
    report_id: str = Path(..., alias='reportId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Report = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/reports/{reportId}/files',
    description=""" Lists files for a report. """,
    tags=['dfareporting_report_handling', 'dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_reports_files_list(
    profile_id: str = Path(..., alias='profileId'),
    report_id: str = Path(..., alias='reportId'),
    max_results: Optional[conint(ge=0, le=10)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    sort_field: Optional[SortField52] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/reports/{reportId}/files/{fileId}',
    description=""" Retrieves a report file by its report ID and file ID. This method supports media download. """,
    tags=['dfareporting_report_handling', 'dfareporting_file_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_reports_files_get(
    profile_id: str = Path(..., alias='profileId'),
    report_id: str = Path(..., alias='reportId'),
    file_id: str = Path(..., alias='fileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/reports/{reportId}/run',
    description=""" Runs a report. """,
    tags=['dfareporting_report_handling', 'dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_reports_run(
    profile_id: str = Path(..., alias='profileId'),
    report_id: str = Path(..., alias='reportId'),
    synchronous: Optional[bool] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/sites',
    description=""" Retrieves a list of sites, possibly filtered. This method supports paging. """,
    tags=[
        'dfareporting_user_profile_management',
        'campaign_operations',
        'subaccount_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_sites_list(
    profile_id: str = Path(..., alias='profileId'),
    accepts_in_stream_video_placements: Optional[bool] = Query(
        None, alias='acceptsInStreamVideoPlacements'
    ),
    accepts_interstitial_placements: Optional[bool] = Query(
        None, alias='acceptsInterstitialPlacements'
    ),
    accepts_publisher_paid_placements: Optional[bool] = Query(
        None, alias='acceptsPublisherPaidPlacements'
    ),
    ad_words_site: Optional[bool] = Query(None, alias='adWordsSite'),
    approved: Optional[bool] = None,
    campaign_ids: Optional[CampaignIds] = Query(None, alias='campaignIds'),
    directory_site_ids: Optional[DirectorySiteIds] = Query(
        None, alias='directorySiteIds'
    ),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField54] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    subaccount_id: Optional[str] = Query(None, alias='subaccountId'),
    unmapped_site: Optional[bool] = Query(None, alias='unmappedSite'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/sites',
    description=""" Updates an existing site. This method supports patch semantics. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_sites_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Site = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/sites',
    description=""" Inserts a new site. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_sites_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Site = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/sites',
    description=""" Updates an existing site. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_sites_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Site = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/sites/{id}',
    description=""" Gets one site by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_sites_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/sizes',
    description=""" Retrieves a list of sizes, possibly filtered. Retrieved sizes are globally unique and may include values not currently in use by your account. Due to this, the list of sizes returned by this method may differ from the list seen in the Trafficking UI. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_sizes_list(
    profile_id: str = Path(..., alias='profileId'),
    height: Optional[conint(ge=0, le=32767)] = None,
    iab_standard: Optional[bool] = Query(None, alias='iabStandard'),
    ids: Optional[Ids] = None,
    width: Optional[conint(ge=0, le=32767)] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/sizes',
    description=""" Inserts a new size. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_sizes_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Size = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/sizes/{id}',
    description=""" Gets one size by ID. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_sizes_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/subaccounts',
    description=""" Gets a list of subaccounts, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_subaccounts_list(
    profile_id: str = Path(..., alias='profileId'),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField54] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/subaccounts',
    description=""" Updates an existing subaccount. This method supports patch semantics. """,
    tags=['dfareporting_user_profile_management', 'subaccount_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_subaccounts_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Subaccount = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/subaccounts',
    description=""" Inserts a new subaccount. """,
    tags=['dfareporting_user_profile_management', 'subaccount_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_subaccounts_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Subaccount = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/subaccounts',
    description=""" Updates an existing subaccount. """,
    tags=['dfareporting_user_profile_management', 'subaccount_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_subaccounts_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: Subaccount = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/subaccounts/{id}',
    description=""" Gets one subaccount by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_subaccounts_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/targetableRemarketingLists',
    description=""" Retrieves a list of targetable remarketing lists, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_targetable_remarketing_lists_list(
    profile_id: str = Path(..., alias='profileId'),
    advertiser_id: str = Query(..., alias='advertiserId'),
    active: Optional[bool] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    name: Optional[str] = None,
    page_token: Optional[str] = Query(None, alias='pageToken'),
    sort_field: Optional[SortField54] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/targetableRemarketingLists/{id}',
    description=""" Gets one remarketing list by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_targetable_remarketing_lists_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/targetingTemplates',
    description=""" Retrieves a list of targeting templates, optionally filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management', 'advertiser_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_targeting_templates_list(
    profile_id: str = Path(..., alias='profileId'),
    advertiser_id: Optional[str] = Query(None, alias='advertiserId'),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField54] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/targetingTemplates',
    description=""" Updates an existing targeting template. This method supports patch semantics. """,
    tags=['dfareporting_user_profile_management', 'targeting_template_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_targeting_templates_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: TargetingTemplate = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/targetingTemplates',
    description=""" Inserts a new targeting template. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_targeting_templates_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: TargetingTemplate = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/targetingTemplates',
    description=""" Updates an existing targeting template. """,
    tags=['dfareporting_user_profile_management', 'targeting_template_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_targeting_templates_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: TargetingTemplate = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/targetingTemplates/{id}',
    description=""" Gets one targeting template by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_targeting_templates_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/userRolePermissionGroups',
    description=""" Gets a list of all supported user role permission groups. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_user_role_permission_groups_list(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/userRolePermissionGroups/{id}',
    description=""" Gets one user role permission group by ID. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_user_role_permission_groups_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/userRolePermissions',
    description=""" Gets a list of user role permissions, possibly filtered. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_user_role_permissions_list(
    profile_id: str = Path(..., alias='profileId'),
    ids: Optional[Ids] = None,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/userRolePermissions/{id}',
    description=""" Gets one user role permission by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_user_role_permissions_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/userRoles',
    description=""" Retrieves a list of user roles, possibly filtered. This method supports paging. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_user_roles_list(
    profile_id: str = Path(..., alias='profileId'),
    account_user_role_only: Optional[bool] = Query(None, alias='accountUserRoleOnly'),
    ids: Optional[Ids] = None,
    max_results: Optional[conint(ge=0, le=1000)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    search_string: Optional[str] = Query(None, alias='searchString'),
    sort_field: Optional[SortField54] = Query(None, alias='sortField'),
    sort_order: Optional[SortOrder] = Query(None, alias='sortOrder'),
    subaccount_id: Optional[str] = Query(None, alias='subaccountId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userprofiles/{profileId}/userRoles',
    description=""" Updates an existing user role. This method supports patch semantics. """,
    tags=['dfareporting_user_profile_management', 'user_role_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_user_roles_patch(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: UserRole = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userprofiles/{profileId}/userRoles',
    description=""" Inserts a new user role. """,
    tags=['dfareporting_user_profile_management', 'user_role_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_user_roles_insert(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: UserRole = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/userprofiles/{profileId}/userRoles',
    description=""" Updates an existing user role. """,
    tags=['dfareporting_user_profile_management', 'user_role_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_user_roles_update(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
    body: UserRole = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/userprofiles/{profileId}/userRoles/{id}',
    description=""" Deletes an existing user role. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_user_roles_delete(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/userRoles/{id}',
    description=""" Gets one user role by ID. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_user_roles_get(
    profile_id: str = Path(..., alias='profileId'),
    id: str = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/videoFormats',
    description=""" Lists available video formats. """,
    tags=['dfareporting_user_profile_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_video_formats_list(
    profile_id: str = Path(..., alias='profileId'),
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userprofiles/{profileId}/videoFormats/{id}',
    description=""" Gets one video format by ID. """,
    tags=['dfareporting_user_profile_management', 'profile_data_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def dfareporting_video_formats_get(
    profile_id: str = Path(..., alias='profileId'),
    id: int = ...,
    field__xgafv: Optional[FieldXgafv] = Query(None, alias='$.xgafv'),
    access_token: Optional[str] = None,
    alt: Optional[Alt] = None,
    callback: Optional[str] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    upload_protocol: Optional[str] = None,
    upload_type: Optional[str] = Query(None, alias='uploadType'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
